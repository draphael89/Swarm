# Terminal/Shell Support Plan for Middleman Chat UI

## Objective
Add terminal support to Middleman’s chat experience so users can:

1. Open and use an embedded interactive terminal in the web UI.
2. View terminal activity generated by agents.
3. Optionally allow agents to use managed terminal sessions as a first-class shared resource.

The solution should fit the current architecture:

- Backend WS server and command routing in `apps/backend/src/ws/server.ts`
- Agent orchestration and tool host in `apps/backend/src/swarm/*`
- TanStack Start UI with `ManagerWsClient` in `apps/ui/src/lib/ws-client.ts`

## Current Architecture Findings

## 1) WebSocket contract and flow
- The app uses one JSON WebSocket channel for all chat/session events.
- Commands are parsed centrally in `SwarmWebSocketServer.parseClientCommand(...)` and dispatched in `handleSocketMessage(...)`.
- Subscription context is agent-scoped (`subscribe`, then event filtering by `agentId`).
- Frontend state comes from `ManagerWsClient`, which already supports request/response via `requestId` and streaming events.

## 2) Agent shell execution today
- Agent runtimes already execute shell/file operations via model runtime tools.
- `CodexAgentRuntime` emits tool events for `commandExecution` output deltas.
- UI currently renders tool output inside message rows (`MessageList`), but not as an interactive terminal.

## 3) UI layout constraints
- Main chat layout is in `apps/ui/src/routes/index.tsx`.
- Right sidebar is currently used for artifacts/schedules (`ArtifactsSidebar`).
- Header controls already include panel toggles; adding one more control is straightforward.

## 4) Security baseline
- App is local-first, but terminal execution is still high-risk.
- Backend already has cwd allowlist concepts and directory validation utilities.
- No dedicated terminal isolation exists yet.

## 5) Reference audit (`~/do-browser`)
- Checked for reusable terminal UI/PTY plumbing patterns.
- No existing xterm.js + PTY implementation was found to reuse directly.
- Recommendation: implement native terminal support in Middleman, while reusing general panel/tabs interaction patterns only.

---

## Approach Options

## Option A: Embedded user terminal panel only
Use xterm.js in UI + backend PTY sessions over WS.

Pros:
- Immediate UX win (VS Code-like terminal).
- Lowest cross-runtime coupling.
- Useful even if agent integration ships later.

Cons:
- Agent terminal visibility remains fragmented (tool logs only).

## Option B: Agent-only terminal tool
Expose terminal session operations as swarm tools (open/write/read/close) without a UI terminal.

Pros:
- Improves agent capabilities quickly.
- Useful for automation flows.

Cons:
- User cannot directly interact/interrupt in a terminal UI.
- Harder to observe live output clearly.

## Option C: Unified terminal service for both user + agent
Single backend PTY/session manager with two consumers:
- Web UI interactive terminal
- Agent-facing terminal APIs / mirroring

Pros:
- One source of truth for terminal lifecycle/security.
- Supports both direct user workflows and agent workflows.
- Enables shared sessions (user can attach to agent session).

Cons:
- More initial design work.

## Recommendation
Implement **Option C** in phases:
1. Ship user interactive terminal first (backend core + UI panel).
2. Add agent terminal integration (mirror existing agent command streams + optional managed terminal tools).

---

## Recommended Architecture Overview

## Core backend component
Create a `TerminalSessionManager` service in backend to own:
- PTY process lifecycle
- Session metadata and ownership
- Input/output streaming
- Permission checks
- Idle cleanup and process teardown

## Transport model
Reuse existing WS connection and protocol, adding terminal-specific commands/events instead of a second socket.

Reason:
- Fits current `ManagerWsClient` architecture.
- Keeps auth/subscription behavior consistent.
- Reduces complexity vs multiplexing separate WS endpoints.

## UI model
Add a bottom-docked terminal panel (desktop) and full-screen terminal sheet (mobile), powered by xterm.js.

## Agent model
Two integration paths:
- **Read-only mirror**: surface agent `commandExecution` deltas in terminal sessions.
- **Managed terminal tools**: optional swarm tools for persistent sessions agents can open/use.

---

## Backend Design

## 1) New backend modules

Add:
- `apps/backend/src/terminal/terminal-types.ts`
- `apps/backend/src/terminal/terminal-session-manager.ts`
- `apps/backend/src/terminal/shell-resolver.ts`

Responsibilities:
- Spawn PTY (`node-pty`) with resolved shell + cwd.
- Track sessions by `terminalId`.
- Track subscribers/attachments (web sockets and/or agent owners).
- Stream output chunks with ordering.
- Handle resize/input/close/signal.

## 2) Session model

Suggested shape:

- `terminalId`
- `ownerAgentId` (or manager-context owner)
- `createdBy`: `'web' | 'agent'`
- `cwd`
- `shell`
- `status`: `'running' | 'exited' | 'closed'`
- `createdAt`, `updatedAt`
- `exitCode`, `exitSignal`
- `cols`, `rows`
- `seq` (monotonic output sequence)
- `outputRingBuffer` (for reattach/replay)

## 3) PTY lifecycle

- `open`: validate cwd, resolve shell, spawn PTY.
- `data`: emit `terminal_output` events with `seq`.
- `exit`: emit `terminal_exit` + mark session terminal.
- `close`: kill process and emit `terminal_closed`.
- `cleanup`: kill idle/exited sessions after configured timeout.

## 4) WS protocol extensions

Extend both contracts:
- `apps/backend/src/protocol/ws-types.ts`
- `apps/ui/src/lib/ws-types.ts`

### New client commands
- `terminal_open`
- `terminal_attach`
- `terminal_input`
- `terminal_resize`
- `terminal_signal`
- `terminal_close`
- `terminal_list`

### New server events
- `terminal_opened`
- `terminal_attached`
- `terminal_output`
- `terminal_exit`
- `terminal_closed`
- `terminal_list`

Include `requestId` on request/response-style events for parity with existing patterns.

## 5) WS server integration points

Update `SwarmWebSocketServer`:
- Parse terminal commands in `parseClientCommand`.
- Route them in `handleSocketMessage`.
- Emit terminal events through existing send/broadcast helpers.
- Extend subscription filtering to allow terminal events scoped to owner/manager context.
- On socket close/error: detach socket from terminal sessions.

## 6) Security model

### Access control
- A socket can only control terminals it owns or is explicitly allowed to attach to.
- Scope permissions to current subscription context (agent/manager).

### CWD controls
- Require `cwd` to resolve within allowed roots (`cwdAllowlistRoots`).
- Default to active agent’s cwd when omitted.

### Shell and env controls
- Resolve shell safely:
  - Unix: `SHELL` fallback (`/bin/bash`)
  - Windows: `ComSpec` fallback (`powershell.exe`)
- Build restricted env (allowlist critical vars + optional passthrough list).

### Abuse controls
- Per-connection and per-agent max sessions.
- Max input chunk size.
- Output ring buffer limits.
- Idle timeout + hard max runtime.

### Feature flag
Add `SWARM_ENABLE_TERMINAL` (default `false` for first release).

## 7) Agent integration backend

## Phase 1 (read-only mirror)
When runtime emits tool execution updates for command execution:
- create ephemeral read-only terminal session keyed by `toolCallId`
- append deltas into that session
- close on tool end

## Phase 2 (agent-managed sessions)
Extend `SwarmToolHost` and `buildSwarmTools` with terminal tools:
- `open_terminal_session`
- `write_terminal_session`
- `read_terminal_session`
- `close_terminal_session`

This makes terminal state explicit and runtime-agnostic (pi + codex).

## 8) Backend tests

Add tests in:
- `apps/backend/src/test/ws-server.test.ts`
- new `apps/backend/src/test/terminal-session-manager.test.ts`

Cover:
- open/input/resize/close flow
- permission denial cases
- cleanup on disconnect
- subscription filtering across agents/managers
- command parsing validation

---

## Frontend Design

## 1) Dependencies

UI:
- `@xterm/xterm`
- `@xterm/addon-fit`
- optional: `@xterm/addon-web-links`, `@xterm/addon-search`

Backend:
- `node-pty`

## 2) UI placement

### Desktop
- Add bottom terminal dock under `MessageList`/`MessageInput` (VS Code-like).
- Height resizable (initial fixed height in first pass; draggable splitter in second pass).

### Mobile
- Terminal opens as full-screen panel/dialog from header action.

### Header controls
- Add terminal toggle button to `ChatHeader` next to artifacts toggle.

## 3) UI components

Add:
- `apps/ui/src/components/chat/TerminalPanel.tsx`
- `apps/ui/src/components/chat/TerminalTabs.tsx` (optional for multi-session)
- `apps/ui/src/components/chat/TerminalToolbar.tsx` (new session, clear, kill, reconnect)

## 4) Client state and WS integration

Update `ManagerWsClient`:
- track terminal sessions and active terminal id
- add methods for terminal commands
- handle `terminal_*` events and notify subscribers

Update `ManagerWsState` with:
- `terminalSessions`
- `activeTerminalId`
- `terminalConnected`/`terminalError` per session

## 5) xterm.js integration details

- Initialize terminal instance on mount; dispose cleanly on unmount.
- Apply `FitAddon` on mount and container resize.
- Send `onData` -> `terminal_input`.
- Send dimensions -> `terminal_resize`.
- Write `terminal_output.data` into xterm.
- Handle reattach by replaying buffered output.

## 6) UX behavior

- If no terminal exists: show CTA to create one.
- Show running/exited badge per session tab.
- Support Ctrl+C via toolbar button (`terminal_signal` SIGINT).
- Preserve session tabs when switching between chat/settings only if same agent context; otherwise context-aware reset.

## 7) Frontend tests

Add/extend tests:
- `apps/ui/src/lib/ws-client.test.ts` for terminal event/command handling
- component tests for terminal panel open/close and output rendering

---

## Agent Integration Plan

## A) Read-only agent terminal stream (recommended first)

Goal: user can watch agent command output in terminal UI with minimal risk.

Implementation:
- detect `tool_execution_*` for command-like tools (`command_execution`, `bash`, etc.)
- map each `toolCallId` to an ephemeral terminal stream
- display under an “Agent Terminals” tab group

No stdin from user to agent command in this phase.

## B) Shared interactive terminal sessions

Goal: agent and user can collaborate in same PTY session.

Implementation:
- agent opens session via swarm tool
- user attaches via UI
- optional lock mode (`agent_only`, `user_only`, `shared`)

Add explicit ownership and attach policy checks to prevent accidental cross-agent access.

## C) One-shot terminal tool fallback

If shared PTY is too complex for initial release, provide one-shot `terminal_exec` for agents and render output in terminal-like UI blocks.

---

## Implementation Phases

## Phase 0: Design spike + protocol draft (0.5-1 day)

Deliverables:
- finalize command/event shapes in ws-types
- confirm session scoping rules
- validate `node-pty` install/runtime on target dev OS

Exit criteria:
- protocol reviewed
- dependency viability confirmed

## Phase 1: Backend PTY service + WS commands (2-3 days)

Deliverables:
- `TerminalSessionManager`
- WS command handling and terminal events
- security guardrails (cwd validation, ownership checks, limits)
- backend tests

Exit criteria:
- terminal can be opened and interacted with using raw WS payloads

## Phase 2: Frontend terminal panel with xterm.js (2-3 days)

Deliverables:
- terminal panel UI + header toggle
- ws-client terminal state and command methods
- session create/input/resize/close UX
- frontend tests

Exit criteria:
- user can run commands interactively in embedded terminal

## Phase 3: Agent integration (2-4 days)

Deliverables:
- read-only agent command stream terminals (required)
- optional managed agent terminal tools (if prioritized)

Exit criteria:
- user can inspect agent shell output in terminal UI

## Phase 4: Hardening + rollout (1-2 days)

Deliverables:
- feature flag default policy
- performance tuning (output throttling, buffer bounds)
- cleanup behavior and reconnection handling
- docs update

Exit criteria:
- stable under long-running output and reconnect scenarios

---

## Dependencies to Install

From repo root:

```bash
pnpm --filter @middleman/backend add node-pty
pnpm --filter @middleman/ui add @xterm/xterm @xterm/addon-fit
pnpm --filter @middleman/ui add @xterm/addon-web-links @xterm/addon-search
```

Notes:
- `node-pty` is native; ensure local build prerequisites exist (Xcode CLT on macOS, build tools on Linux/Windows).
- If package compatibility issues arise on a specific platform, evaluate prebuilt alternatives before rollout.

---

## Suggested WS Contract Sketch (Initial)

```ts
// ClientCommand additions
| { type: 'terminal_open'; agentId?: string; cwd?: string; shell?: string; cols?: number; rows?: number; requestId?: string }
| { type: 'terminal_attach'; terminalId: string; requestId?: string }
| { type: 'terminal_input'; terminalId: string; data: string }
| { type: 'terminal_resize'; terminalId: string; cols: number; rows: number }
| { type: 'terminal_signal'; terminalId: string; signal: 'SIGINT' | 'SIGTERM' | 'SIGKILL' }
| { type: 'terminal_close'; terminalId: string }
| { type: 'terminal_list'; agentId?: string; requestId?: string }

// ServerEvent additions
| { type: 'terminal_opened'; terminal: TerminalSessionSummary; replay?: string; requestId?: string }
| { type: 'terminal_attached'; terminal: TerminalSessionSummary; replay?: string; requestId?: string }
| { type: 'terminal_output'; terminalId: string; seq: number; data: string }
| { type: 'terminal_exit'; terminalId: string; exitCode: number | null; signal: string | null }
| { type: 'terminal_closed'; terminalId: string; reason: 'user' | 'agent' | 'idle_timeout' | 'process_exit' }
| { type: 'terminal_list'; terminals: TerminalSessionSummary[]; requestId?: string }
```

---

## Risks and Mitigations

1. Native dependency friction (`node-pty`):
- Mitigation: phase-0 install spike + documented prerequisites.

2. Terminal output flooding WS/UI:
- Mitigation: chunking, bounded buffers, optional debounce/throttle, seq-based replay.

3. Permission leaks across agent contexts:
- Mitigation: strict owner checks and manager-context gating for every terminal command.

4. UX complexity with multiple sessions:
- Mitigation: start with one active session + optional tabs, keep advanced sharing for later phase.

5. Divergence between agent runtime tools and managed terminal:
- Mitigation: ship read-only mirroring first; only add managed agent tools if real workflow demands it.

---

## Open Questions

1. Should terminal sessions persist across backend restarts, or be strictly ephemeral?
2. Should users be allowed to attach to worker-owned terminals when subscribed to manager only?
3. Do we want text transcript persistence for audit/debug, or memory-only buffers?
4. Should terminal access be enabled by default in local dev but disabled by default in production mode?
5. Is read-only mirroring of agent command output sufficient, or do we need full shared interactive terminals in v1?
